<!DOCTYPE html>
<html lang="en">

<head>
	<title>Virtual Temple</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link href="https://fonts.googleapis.com/css2?family=Cormorant+Unicase:wght@500&display=swap" rel="stylesheet">

	<style>
		body {
			margin: 0;
			padding: 0;
			overflow: hidden
		}

		a:hover {
			color: #a06851;
		}

		#blocker {
			position: absolute;
			width: 100%;
			height: 100%;
			/* background-color: rgba(0, 0, 0, 0.3); */
			background-color: rgba(0, 0, 0, 0);
		}

		#instructions {
			width: 100%;
			height: 100%;

			display: -webkit-box;
			display: -moz-box;
			display: box;

			-webkit-box-orient: horizontal;
			-moz-box-orient: horizontal;
			box-orient: horizontal;

			-webkit-box-pack: center;
			-moz-box-pack: center;
			box-pack: center;

			-webkit-box-align: center;
			-moz-box-align: center;
			box-align: center;

			color: #ffffff;
			text-align: center;
			font-family: 'Cormorant Unicase', serif;

			font-size: 30px;
			line-height: 25px;

			cursor: pointer;
		}
	</style>
</head>

<body>
	<div id="blocker">
		<div id="instructions">
			<span style="font-size:144px" ;> <a> ◎ <br /> <br /> Enter</a> </span>
			<br />
			<br />
			<br />
			Keys &nbsp; ← → ↑ ↓
			<br /> <br />

			Mouse &nbsp;&nbsp; ⭤⭥ &nbsp;&nbsp;
		</div>
	</div>
	<div id="container"></div>


	<script type="module">
		import * as THREE from '/threetest/build/three.module.js';
		import Stats from '/threetest/examples/jsm/libs/stats.module.js';
		import {
			PointerLockControls
		} from '/threetest/examples/jsm/controls/PointerLockControls.js';
		import {
			GUI
		} from '/threetest/examples/jsm/libs/dat.gui.module.js';

		/*




		THREEJS BEGIN





		*/


		let camera, scene, renderer, controls;
		let geometry, materialOptions, starStuff, stars, stats, container, starGroup
		let light
		let clock = new THREE.Clock();

		const objects = [];
		let raycaster;
		container = document.getElementById('container');

		let moveForward = false;
		let moveBackward = false;
		let moveLeft = false;
		let moveRight = false;
		let canJump = false;

		let prevTime = performance.now();
		const velocity = new THREE.Vector3();
		const direction = new THREE.Vector3();
		const vertex = new THREE.Vector3();


		// PRESENTATION
		const speederBoi = 200
		const starQtyNum = 50000

		// // WORKING
		// const speederBoi = 800
		// const starQtyNum = 50000

		function init() {

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);

			const gui = new GUI();

			scene = new THREE.Scene()
			scene.background = new THREE.Color('black');
			// scene.background = new THREE.Color('lightgrey');
			// scene.background = new THREE.Color('black');
			scene.fog = new THREE.Fog('lightgrey', 0, 400);


			starForge()

			function starForge() {
				let starQty = starQtyNum;
				geometry = new THREE.SphereGeometry(1000, 100, 1);
				materialOptions = {
					size: 1.0
				};

				starStuff = new THREE.PointsMaterial(materialOptions);
				for (let i = 0; i < starQty; i++) {

					const x = 1000
					const y = 2000
					const z = 2500

					let starVertex = new THREE.Vector3();
					starVertex.x = Math.random() * 2000 - x / 2;
					starVertex.y = Math.random() * 2000 - y / 2;
					starVertex.z = Math.random() * 2000 - z / 2;

					geometry.vertices.push(starVertex);

				}
				stars = new THREE.Points(geometry, starStuff);
				starGroup = new THREE.Object3D();

				starGroup.add(stars)
				scene.add(starGroup);
			}

			controls = new PointerLockControls(camera, document.body);
			const instructions = document.getElementById('instructions');

			instructions.addEventListener('click', function() {
				controls.lock();
			}, false);

			// document.addEventListener(event, function, useCapture)
			// event = action . function - thing to be done.
			controls.addEventListener('lock', function() {
				instructions.style.display = 'none';
				blocker.style.display = 'none';
			});

			controls.addEventListener('unlock', function() {
				blocker.style.display = 'block';
				instructions.style.display = '';
			});

			scene.add(controls.getObject());

			const onKeyDown = function(event) {
				switch (event.keyCode) {
					case 38: // up
					case 87: // w
						moveForward = true;
						break;
					case 37: // left
					case 65: // a
						moveLeft = true;
						break;
					case 40: // down
					case 83: // s
						moveBackward = true;
						break;
					case 39: // right
					case 68: // d
						moveRight = true;
						break;
					case 32: // space
						if (canJump === true) velocity.y += 350;
						canJump = false;
						break;
				}
			};
			const onKeyUp = function(event) {
				switch (event.keyCode) {
					case 38: // up
					case 87: // w
						moveForward = false;
						break;
					case 37: // left
					case 65: // a
						moveLeft = false;
						break;
					case 40: // down
					case 83: // s
						moveBackward = false;
						break;
					case 39: // right
					case 68: // d
						moveRight = false;
						break;
				}
			};

			document.addEventListener('keydown', onKeyDown, false);
			document.addEventListener('keyup', onKeyUp, false);

			raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 0);

			//////////////////////////////////////////////////////////////////////////////////////

			const ambientLight = new THREE.AmbientLight('white', 1); // soft white light
			scene.add(ambientLight);

			light = new THREE.PointLight('white', 10, 100);
			light.castShadow = true;
			// light.intensity = 10
			// light.decay = 100
			// light.distance = 100

			const geometry2 = new THREE.SphereGeometry(0.5, 4, 4);
			const material2 = new THREE.MeshBasicMaterial({
				color: 'white'
			});

			light.position.copy(controls.getObject().position)
			camera.add(light);

			let pointColor = "#ff5808";

			let plane = getPlane(1000);

			let radius = 20
			let tube = 7

			plane.name = 'plane-1';
			plane.rotation.x = Math.PI / 2;
			plane.position.y = -30;
			plane.position.z = -200;


			scene.add(plane);

			camera.position.x = 0;
			camera.position.y = 0;
			camera.position.z = 150;

			let spotLight0 = new THREE.SpotLight(0xcccccc);
			spotLight0.position.set(-0, 100, -10);
			spotLight0.intensity = 20
			scene.add(spotLight0);

			//////////////////////////////////////////////////////////////////////////

			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			// renderer.setClearColor('rgb(120, 120, 120)');
			renderer.shadowMap.enabled = true;

			document.body.appendChild(renderer.domElement);
			window.addEventListener('resize', onWindowResize, false);

			container.appendChild(renderer.domElement);
			stats = new Stats();
			container.appendChild(stats.dom);

			setRing1(-75)
			setRing2(-50)
			setRing3(-25)
			setRing4(0)
			setRing5(25)


const audioListener = new THREE.AudioListener();
camera.add(audioListener);
const oceanAmbientSound = new THREE.Audio(audioListener);
scene.add(oceanAmbientSound);
const loader = new THREE.AudioLoader();

loader.load(
'audio/devmusic.mp3',
function(audioBuffer) {
oceanAmbientSound.setBuffer(audioBuffer);
oceanAmbientSound.play();
},

function(xhr) {
console.log((xhr.loaded / xhr.total * 100) + '% loaded');
},
function(err) {
console.log('An error happened');
}
);

		}

		///////////////////////////////////////////////////////////////////////////
		///////////////////////// GLOBAL VARIABLES ////////////////////////////////
		///////////////////////////////////////////////////////////////////////////

		let time = 0;
		let ringRadius = 50;
		let ringGroup1, ringGroup2, ringGroup6, ringGroup3, ringGroup4, ringGroup5
		let ringCount = 30

		///////////////////////////////////////////////////////////////////////////
		///////////////////////// FUNCTIONS ////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////

		function setRing1(z) {

			const geometry = new THREE.SphereGeometry(4, 32, 32)
			const material = new THREE.MeshPhongMaterial({
				color: 'grey'
			})

			ringGroup1 = new THREE.Object3D();

			for (let i = 0; i < ringCount; i++) {
				const mesh = new THREE.Mesh(geometry, material)
				const t = i / ringCount * 2 * Math.PI
				mesh.position.x = Math.cos(t) * ringRadius;
				mesh.position.y = Math.sin(t) * ringRadius;
				ringGroup1.position.set(0, 0, z)

				ringGroup1.add(mesh)
				scene.add(ringGroup1)
			}
		}

		function setRing2(z) {

			const geometry = new THREE.SphereGeometry(4, 32, 32)
			const material = new THREE.MeshPhongMaterial({
				color: 'grey'
			})

			ringGroup2 = new THREE.Object3D();

			for (let i = 0; i < ringCount; i++) {
				const mesh = new THREE.Mesh(geometry, material)
				const t = i / ringCount * 2 * Math.PI
				mesh.position.x = Math.cos(t) * ringRadius;
				mesh.position.y = Math.sin(t) * ringRadius;
				ringGroup2.position.set(0, 0, z)

				ringGroup2.add(mesh)
				scene.add(ringGroup2)
			}
		}

		function setRing3(z) {

			const geometry = new THREE.SphereGeometry(4, 32, 32)
			const material = new THREE.MeshPhongMaterial({
				color: 'grey'
			})

			ringGroup3 = new THREE.Object3D();

			for (let i = 0; i < ringCount; i++) {
				const mesh = new THREE.Mesh(geometry, material)
				const t = i / ringCount * 2 * Math.PI
				mesh.position.x = Math.cos(t) * ringRadius;
				mesh.position.y = Math.sin(t) * ringRadius;
				ringGroup3.position.set(0, 0, z)

				ringGroup3.add(mesh)
				scene.add(ringGroup3)
			}
		}

		function setRing4(z) {

			const geometry = new THREE.SphereGeometry(4, 32, 32)
			const material = new THREE.MeshPhongMaterial({
				color: 'grey'
			})

			ringGroup4 = new THREE.Object3D();

			for (let i = 0; i < ringCount; i++) {
				const mesh = new THREE.Mesh(geometry, material)
				const t = i / ringCount * 2 * Math.PI
				mesh.position.x = Math.cos(t) * ringRadius;
				mesh.position.y = Math.sin(t) * ringRadius;
				ringGroup4.position.set(0, 0, z)

				ringGroup4.add(mesh)
				scene.add(ringGroup4)
			}
		}

		function setRing5(z) {

			const geometry = new THREE.SphereGeometry(4, 32, 32)
			const material = new THREE.MeshPhongMaterial({
				color: 'grey'
			})

			ringGroup5 = new THREE.Object3D();

			for (let i = 0; i < ringCount; i++) {
				const mesh = new THREE.Mesh(geometry, material)
				const t = i / ringCount * 2 * Math.PI
				mesh.position.x = Math.cos(t) * ringRadius;
				mesh.position.y = Math.sin(t) * ringRadius;
				ringGroup5.position.set(0, 0, z)

				ringGroup5.add(mesh)
				scene.add(ringGroup5)
			}
		}




		function getPlane(size) {
			const geometry = new THREE.PlaneGeometry(50, size);
			const material = new THREE.MeshBasicMaterial({
				color: 'black',
				side: THREE.DoubleSide
			});
			const mesh = new THREE.Mesh(
				geometry,
				material
			);
			// mesh.receiveShadow = true;
			return mesh;
		}


		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			requestAnimationFrame(animate);
			stats.update();
			render()
		}

		///////////////////////////////////////////////////////////////////////////
		///////////////////////// RENDER ////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////

		function render() {
			const performanceNow = performance.now();
			// console.log(camera.position)

			if (controls.isLocked === true) {
				raycaster.ray.origin.copy(controls.getObject().position);
				raycaster.ray.origin.y -= 10;
				const intersections = raycaster.intersectObjects(objects);
				const onObject = intersections.length > 0;
				const delta = (performanceNow - prevTime) / 1000;
				velocity.x -= velocity.x * 10.0 * delta;
				velocity.z -= velocity.z * 10.0 * delta;
				direction.z = Number(moveForward) - Number(moveBackward);
				direction.x = Number(moveRight) - Number(moveLeft);
				direction.normalize(); // this ensures consistent movements in all directions
				if (moveForward || moveBackward) velocity.z -= direction.z * speederBoi * delta;
				if (moveLeft || moveRight) velocity.x -= direction.x * speederBoi * delta;
				controls.moveRight(-velocity.x * delta);
				controls.moveForward(-velocity.z * delta);
				controls.getObject().position.y += (velocity.y * delta); // new behavior
				if (controls.getObject().position.y < 0) {
					velocity.y = 0;
					controls.getObject().position.y = 0;
				}
			}

			for (let i = 0; i < starGroup.children.length; i++) {
				const object = starGroup.children[i];
				object.rotation.y = performanceNow * (i < 1 ? i - 0.000015 : -(i + 1));
			}

			prevTime = performanceNow;

			light.position.set(0, 0, 0);

			time = clock.getElapsedTime() * 0.03 * Math.PI;



			ringGroup1.rotation.z += 0.0015
			ringGroup2.rotation.z += 0.0013
			ringGroup3.rotation.z += 0.0011
			ringGroup4.rotation.z += 0.0009
			ringGroup5.rotation.z += 0.0007




			renderer.render(scene, camera);
		}

		init();
		animate();
	</script>
</body>

</html>
