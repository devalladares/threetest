<!DOCTYPE html>
<html lang="en">

<head>
	<title>Virtual Temple</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link href="https://fonts.googleapis.com/css2?family=Cormorant+Unicase:wght@500&display=swap" rel="stylesheet">

	<style>
		body {
			margin: 0;
			padding: 0;
			overflow: hidden
		}

		a {
			color: DimGrey;
			-o-transition: 1s;
			-ms-transition: 1s;
			-moz-transition: 1s;
			-webkit-transition: 1s;
			transition: 1s;
		}

		a:hover {
			color: white;
		}

		#blocker {
			position: absolute;
			width: 100%;
			height: 100%;
			/* background-color: rgba(0, 0, 0, 0.3); */
			background-color: rgba(0, 0, 0, 0);
			/* background: linear-gradient(to bottom, #000000 10%, #ff9900 75%); */
			/* opacity: 0.5; */
			/* mix-blend-mode: exclusion; */
			/* mix-blend-mode: luminosity; */
		}

		#instructions {

			width: 100%;
			height: 100%;
			display: -webkit-box;
			display: -moz-box;
			display: box;
			-webkit-box-orient: horizontal;
			-moz-box-orient: horizontal;
			box-orient: horizontal;
			-webkit-box-pack: center;
			-moz-box-pack: center;
			box-pack: center;
			-webkit-box-align: center;
			-moz-box-align: center;
			box-align: center;
			color: #ffffff;
			text-align: center;
			font-family: 'Cormorant Unicase', serif;
			font-size: 30px;
			line-height: 25px;
			cursor: cell;
		}
	</style>
</head>

<body>
	<div id="blocker">
		<div id="instructions"><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
			<span style="font-size:144px" ;> <a>◎<br /><br /> Enter</a> </span>
			<br />
			<br />
			<br />
			Keys &nbsp; ← → ↑ ↓
			<br /> <br />
			Mouse &nbsp;&nbsp; ⭤⭥ &nbsp;&nbsp;
		</div>
	</div>
	<div id="container"></div>

	<script type="module">
	import * as THREE from '/threetest/build/three.module.js';
	import Stats from '/threetest/examples/jsm/libs/stats.module.js';
	import {
		PointerLockControls
	} from '/threetest/examples/jsm/controls/PointerLockControls.js';
	import {
		GUI
	} from '/threetest/examples/jsm/libs/dat.gui.module.js';
		import {
			Water
		} from '/threetest/examples/jsm/objects/Water.js';


		/*




		THREEJS BEGIN





		*/

		// PRESENTATION
		// const speederBoi = 100
		// let presentation = true

		// // WORKING
		const speederBoi = 800
		let presentation = false

		/////////////////////////////////////////////////////
		/////////////////////// VARIABLES ///////////////////////


		let camera, scene, renderer, controls;
		let geometry, materialOptions, starStuff, stars, stats, container, starGroup
		let light
		let clock = new THREE.Clock();
		let water, sun, sky

		const objects = [];
		let raycaster;
		container = document.getElementById('container');

		let moveForward = false;
		let moveBackward = false;
		let moveLeft = false;
		let moveRight = false;
		let canJump = false;

		let prevTime = performance.now();
		const velocity = new THREE.Vector3();
		const direction = new THREE.Vector3();
		const vertex = new THREE.Vector3();
		const audioListener = new THREE.AudioListener();
		const oceanAmbientSound = new THREE.Audio(audioListener);

		/////////////////////////////////////////////////////
		/////////////////////// INITIAL ///////////////////////

		function init() {

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 5, 1000);
			camera.position.set(0, 0, 150)

			scene = new THREE.Scene()
			scene.background = new THREE.Color('black');
			// scene.background = new THREpoE.Color('lightgrey');
			scene.fog = new THREE.Fog('black', 0, 800);

			renderer = new THREE.WebGLRenderer({
				// antialias: true
			});
			const minpixelRatio = 1.75
			const pixelRatio = Math.min(minpixelRatio, window.devicePixelRatio)
			renderer.setPixelRatio(pixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			// renderer.setClearColor('rgb(120, 120, 120)');
			renderer.shadowMap.enabled = true;

			document.body.appendChild(renderer.domElement);
			window.addEventListener('resize', onWindowResize, false);

			container.appendChild(renderer.domElement);
			stats = new Stats();
			container.appendChild(stats.dom);

			/////////////////////////////////////////////////////
			/////////////////////// AUDIO ///////////////////////

			if (presentation) {

				camera.add(audioListener);
				scene.add(oceanAmbientSound);

				const loader = new THREE.AudioLoader();
				loader.load(
					'audio/devmusic.mp3',
					function(audioBuffer) {
						oceanAmbientSound.setBuffer(audioBuffer);
					},

					function(xhr) {
						console.log((xhr.loaded / xhr.total * 100) + '% loaded');
					},
					function(err) {
						console.log('An error happened');
					});
			}

			//////////////////// STARS ////////////////////////
			///////////////////////////////////////////////////////

			starForge()

			function starForge() {
				const starQty = 25000;
				geometry = new THREE.SphereGeometry(100, 1, 1);
				materialOptions = {
					size: 1.0,
					fog: false
				};


				starStuff = new THREE.PointsMaterial(materialOptions);
				for (let i = 0; i < starQty; i++) {

					const x = 1000
					const y = 2000
					const z = 2500

					let starVertex = new THREE.Vector3();
					starVertex.x = Math.random() * 1000 - x / 2;
					starVertex.y = Math.random() * 1000 - 200
					starVertex.z = Math.random() * 2000 - z / 2;

					geometry.vertices.push(starVertex);

				}
				stars = new THREE.Points(geometry, starStuff);
				starGroup = new THREE.Object3D();

				starGroup.add(stars)
				scene.add(starGroup);
			}

			//////////////////// CONTROLS ///////////////////////////////////
			///////////////////////////////////////////////////////

			controls = new PointerLockControls(camera, document.body);
			const instructions = document.getElementById('instructions');

			instructions.addEventListener('click', function() {
				controls.lock();
				if (presentation = true) {
					oceanAmbientSound.play()
					let loopingEnabled = oceanAmbientSound.loop;
					oceanAmbientSound.loop = true
				};
			}, false);

			// document.addEventListener(event, function, useCapture)
			// event = action . function - thing to be done.
			controls.addEventListener('lock', function() {
				instructions.style.display = 'none';
				blocker.style.display = 'none';

			});

			controls.addEventListener('unlock', function() {
				blocker.style.display = 'block';
				instructions.style.display = '';
			});

			scene.add(controls.getObject());

			const onKeyDown = function(event) {
				switch (event.keyCode) {
					case 38: // up
					case 87: // w
						moveForward = true;
						break;
					case 37: // left
					case 65: // a
						moveLeft = true;
						break;
					case 40: // down
					case 83: // s
						moveBackward = true;
						break;
					case 39: // right
					case 68: // d
						moveRight = true;
						break;
					case 32: // space
						if (canJump === true) velocity.y += 350;
						canJump = false;
						break;
				}
			};
			const onKeyUp = function(event) {
				switch (event.keyCode) {
					case 38: // up
					case 87: // w
						moveForward = false;
						break;
					case 37: // left
					case 65: // a
						moveLeft = false;
						break;
					case 40: // down
					case 83: // s
						moveBackward = false;
						break;
					case 39: // right
					case 68: // d
						moveRight = false;
						break;
				}
			};

			document.addEventListener('keydown', onKeyDown, false);
			document.addEventListener('keyup', onKeyUp, false);

			raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 0);

			//////////////////////////////////////////////////////////////////////////////////////

			const ambientLight = new THREE.AmbientLight('white', 1); // soft white light
			scene.add(ambientLight);

			light = new THREE.PointLight('white', 10, 100);
			light.castShadow = true;
			light.intensity = 20
			light.position.copy(controls.getObject().position)
			camera.add(light);

			const geometry2 = new THREE.SphereBufferGeometry(15, 5, 5);
			const material2 = new THREE.MeshBasicMaterial({
				color: 'white'
			});
			const sphere = new THREE.Mesh(geometry2, material2);
			light.physicallyCorrectLights = true

			light.position.copy(controls.getObject().position)
			camera.add(light);
			light.add(sphere);


			/////////////////////////////// WATER   ///////////////////////////////////////////

			const waterGeometry = new THREE.PlaneBufferGeometry(500, 2000);

			water = new Water(
				waterGeometry, {
					textureWidth: 512,
					textureHeight: 512,
					waterNormals: new THREE.TextureLoader().load('examples/jsm/textures/waternormals.jpg', function(texture) {
						texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
					}),
					alpha: 1.0,
					sunDirection: new THREE.Vector3(),
					sunColor: 0xffffff,
					waterColor: 0x001e0f,
					distortionScale: 3.7,
					fog: scene.fog !== undefined
				}
			);

			water.rotation.x = -Math.PI / 2;
			water.position.y = -30
			water.position.z = -800
			scene.add(water);

			/////////////////////////////// PLANE + LIGHT + RING ///////////////////////////////////

			const planeGeometry = new THREE.PlaneGeometry(50, 2000);
			const planeMaterialBlack = new THREE.MeshStandardMaterial({
				color: 'black',
				side: THREE.DoubleSide
			});
			const planeMeshBlack = new THREE.Mesh(
				planeGeometry,
				planeMaterialBlack
			);
			planeMeshBlack.rotation.x = Math.PI / 2;
			planeMeshBlack.position.y = -25;
			planeMeshBlack.position.z = -800;

			scene.add(planeMeshBlack);

			let spotLight0 = new THREE.SpotLight(0xcccccc);
			spotLight0.position.set(-0, 200, -10);
			spotLight0.intensity = 20
			scene.add(spotLight0);
			spotLight0.lookAt(camera.position)

			setRing()

		}

		///////////////////////////////////////////////////////////////////////////
		///////////////////////// GLOBAL VARIABLES ////////////////////////////////
		///////////////////////////////////////////////////////////////////////////

		let time = 0;
		const ringRadius = 50;
		let ringGroup, newRing
		const ringCount = 30
		const rings = []
		const ringNumber = 3

		///////////////////////////////////////////////////////////////////////////
		///////////////////////// FUNCTIONS ////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////

		function setRing() {
			ringGroup = new THREE.Object3D();
			const geometry = new THREE.SphereBufferGeometry(4, 24, 24)



			const material = new THREE.MeshPhongMaterial({
				color: 'grey'
			})
			const mainMesh = new THREE.Mesh(geometry, material)

			for (let i = 0; i < ringCount; i++) {
				const mesh = mainMesh.clone();
				const t = i / ringCount * 2 * Math.PI
				mesh.position.x = Math.cos(t) * ringRadius;
				mesh.position.y = Math.sin(t) * ringRadius;
				ringGroup.add(mesh)
			}
			ringGroup.position.set(0, 0, 0)

			for (let j = 0; j < ringNumber; j++) {
				addRing((j * -30) + 50)
			}
		}

		function addRing(j) {
			newRing = ringGroup.clone()
			newRing.position.z = j
			newRing.rotation.z = j
			rings.push(newRing)
			scene.add(newRing)

		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			requestAnimationFrame(animate);
			stats.update();
			render()
		}

		///////////////////////////////////////////////////////////////////////////
		///////////////////////// RENDER ////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////

		function render() {
			const performanceNow = performance.now();

			if (controls.isLocked === true) {
				raycaster.ray.origin.copy(controls.getObject().position);
				raycaster.ray.origin.y -= 10;
				const intersections = raycaster.intersectObjects(objects);
				const onObject = intersections.length > 0;
				const delta = (performanceNow - prevTime) / 1000;
				velocity.x -= velocity.x * 10.0 * delta;
				velocity.z -= velocity.z * 10.0 * delta;
				direction.z = Number(moveForward) - Number(moveBackward);
				direction.x = Number(moveRight) - Number(moveLeft);
				direction.normalize(); // this ensures consistent movements in all directions
				if (moveForward || moveBackward) velocity.z -= direction.z * speederBoi * delta;
				if (moveLeft || moveRight) velocity.x -= direction.x * speederBoi * delta;
				controls.moveRight(-velocity.x * delta);
				controls.moveForward(-velocity.z * delta);
				controls.getObject().position.y += (velocity.y * delta); // new behavior
				if (controls.getObject().position.z > 200) {
					velocity.z = 0;
					controls.getObject().position.z = 200;
				}
				if (controls.getObject().position.x > 250) {
					velocity.x = 0;
					controls.getObject().position.x = 250;
				}
				if (controls.getObject().position.x < -250) {
					velocity.x = 0;
					controls.getObject().position.x = -250;
				}
			}

			for (let i = 0; i < starGroup.children.length; i++) {
				const object = starGroup.children[i];
				object.rotation.y = performanceNow * -0.000015
			}

			prevTime = performanceNow;
			light.position.set(0, -10, 0);

			rings.forEach((element, ndx) => {
				element.rotation.z += 0.00025 * (ndx + 1)

				let distance = camera.position.distanceTo(element.position)

				if (distance < 100) {
					const scale = (num, in_min, in_max, out_min, out_max) => {
						return (num - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
					}
					let ringRotator2 = scale(distance, 100, 0, 0.0005, 0.010)
					let ringRotator3 = ringRotator2 > 0.010 ? 0.010 : ringRotator2 < 0.0005 ? 0.0005 : ringRotator2
					element.rotation.z += ringRotator3

				} else {
					element.rotation.z += 0.0005
				}
			});









			renderer.render(scene, camera);
		}

		init();
		animate();
	</script>
</body>

</html>
