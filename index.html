<!DOCTYPE html>
<html lang="en">

<head>
	<title>Virtual Temple</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link href="https://fonts.googleapis.com/css2?family=Cormorant+Unicase:wght@500&display=swap" rel="stylesheet">

	<style>
		body {
			margin: 0;
			padding: 0;
			overflow: hidden
		}

		a:hover {
			color: #a06851;
		}

		#blocker {
			position: absolute;
			width: 100%;
			height: 100%;
			/* background-color: rgba(0, 0, 0, 0.3); */
			background-color: rgba(0, 0, 0, 0);
		}

		#instructions {
			width: 100%;
			height: 100%;

			display: -webkit-box;
			display: -moz-box;
			display: box;

			-webkit-box-orient: horizontal;
			-moz-box-orient: horizontal;
			box-orient: horizontal;

			-webkit-box-pack: center;
			-moz-box-pack: center;
			box-pack: center;

			-webkit-box-align: center;
			-moz-box-align: center;
			box-align: center;

			color: #ffffff;
			text-align: center;
			font-family: 'Cormorant Unicase', serif;

			font-size: 30px;
			line-height: 70px;

			cursor: pointer;
		}
	</style>
</head>

<body>
	<div id="blocker">
		<div id="instructions">
			<span style="font-size:144px"> <a> ◎ <br /> Enter</a> </span>
			<br />
			&nbsp;&nbsp; Move &nbsp; ← → ↑ ↓ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ◘ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Look &nbsp;&nbsp; ⭤ Mouse⭥ &nbsp;&nbsp;
		</div>
	</div>
	<div id="container"></div>

	<script type="module">
		import * as THREE from './threetest/build/three.module.js';
		import Stats from './threetest/examples/jsm/libs/stats.module.js';
		import {
			PointerLockControls
		} from './threetest/examples/jsm/controls/PointerLockControls.js';
		import {
			GUI
		} from './threetest/examples/jsm/libs/dat.gui.module.js';

/*




THREEJS BEGIN





*/


		let camera, scene, renderer, controls;
		let geometry, materialOptions, starStuff, stars, stats, container
		let light
		let clock = new THREE.Clock();

		const objects = [];
		let raycaster;
		container = document.getElementById('container');

		let moveForward = false;
		let moveBackward = false;
		let moveLeft = false;
		let moveRight = false;
		let canJump = false;

		let prevTime = performance.now();
		const velocity = new THREE.Vector3();
		const direction = new THREE.Vector3();
		const vertex = new THREE.Vector3();


		// // PRESENTATION
		const speederBoi = 200
		const starQtyNum = 100000

		// WORKING
		// const speederBoi = 800
		// const starQtyNum = 100

		function init() {

			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);

			const gui = new GUI();

			scene = new THREE.Scene()
			scene.background = new THREE.Color('black');
			// scene.background = new THREE.Color('lightgrey');

			// scene.fog = new THREE.Fog('lightgrey', 0, 200);

			starForge()

			function starForge() {
				let starQty = starQtyNum;
				geometry = new THREE.SphereGeometry(1000, 100, 1);
				materialOptions = {
					size: 1.0
				};

				starStuff = new THREE.PointsMaterial(materialOptions);
				for (let i = 0; i < starQty; i++) {

					let starVertex = new THREE.Vector3();
					starVertex.x = Math.random() * 2000 - 1000;
					starVertex.y = Math.random() * 2000 - 1000;
					starVertex.z = Math.random() * 2000 - 1000;

					geometry.vertices.push(starVertex);

				}
				stars = new THREE.Points(geometry, starStuff);
				scene.add(stars);
			}

			controls = new PointerLockControls(camera, document.body);
			const instructions = document.getElementById('instructions');

			instructions.addEventListener('click', function() {
				controls.lock();
			}, false);

			// document.addEventListener(event, function, useCapture)
			// event = action . function - thing to be done.
			controls.addEventListener('lock', function() {
				instructions.style.display = 'none';
				blocker.style.display = 'none';
			});

			controls.addEventListener('unlock', function() {
				blocker.style.display = 'block';
				instructions.style.display = '';
			});

			scene.add(controls.getObject());

			const onKeyDown = function(event) {
				switch (event.keyCode) {
					case 38: // up
					case 87: // w
						moveForward = true;
						break;
					case 37: // left
					case 65: // a
						moveLeft = true;
						break;
					case 40: // down
					case 83: // s
						moveBackward = true;
						break;
					case 39: // right
					case 68: // d
						moveRight = true;
						break;
					case 32: // space
						if (canJump === true) velocity.y += 350;
						canJump = false;
						break;
				}
			};
			const onKeyUp = function(event) {
				switch (event.keyCode) {
					case 38: // up
					case 87: // w
						moveForward = false;
						break;
					case 37: // left
					case 65: // a
						moveLeft = false;
						break;
					case 40: // down
					case 83: // s
						moveBackward = false;
						break;
					case 39: // right
					case 68: // d
						moveRight = false;
						break;
				}
			};

			document.addEventListener('keydown', onKeyDown, false);
			document.addEventListener('keyup', onKeyUp, false);

			raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 0);

			//////////////////////////////////////////////////////////////////////////////////////

			const ambientLight = new THREE.AmbientLight('white', 1); // soft white light
			scene.add(ambientLight);

			light = new THREE.PointLight('white', 10, 100);
			light.castShadow = true;


			const geometry2 = new THREE.SphereGeometry(0.5, 4, 4);
			const material2 = new THREE.MeshBasicMaterial({
				color: 'white'
			});



			light.position.copy(controls.getObject().position)
			camera.add(light);

			var pointColor = "#ff5808";


			let plane = getPlane(1000);

			let radius = 20
			let tube = 7

			plane.name = 'plane-1';
			plane.rotation.x = Math.PI / 2;
			plane.position.y = -30;

			scene.add(plane);

			camera.position.x = 0;
			camera.position.y = 0;
			camera.position.z = 100;

			//////////////////////////////////////////////////////////////////////////

			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			// renderer.setClearColor('rgb(120, 120, 120)');
			renderer.shadowMap.enabled = true;

			document.body.appendChild(renderer.domElement);
			window.addEventListener('resize', onWindowResize, false);

			container.appendChild(renderer.domElement);
			stats = new Stats();
			container.appendChild(stats.dom);

			// scene.add(new THREE.GridHelper(200, 10));

			for (let i = 0; i < 20; i++) {
				setRing1()
			}
		}

		let ring1 = [];
		let time = 0;
		let radius = 50;

		function setRing1() {

			const geometry = new THREE.SphereGeometry(4, 32, 32)
			const material = new THREE.MeshPhongMaterial({
				color: 'grey'
			})

			let c = new THREE.Mesh(geometry, material)
			c.receiveShadow = true;

			scene.add(c);
			ring1.push(c);



			var spotLight0 = new THREE.SpotLight(0xcccccc);
			spotLight0.position.set(-0, 60, -10);
			scene.add(spotLight0);

		}

		///////////////////////////////////////////////////////////////////////////

		function getPlane(size) {
			const geometry = new THREE.PlaneGeometry(50, size);
			const material = new THREE.MeshBasicMaterial({
				color: 'black',
				side: THREE.DoubleSide
			});
			const mesh = new THREE.Mesh(
				geometry,
				material
			);
			mesh.receiveShadow = true;
			return mesh;
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			requestAnimationFrame(animate);
			stats.update();
			render()
		}

		function render() {
			const performanceNow = performance.now();

			if (controls.isLocked === true) {
				raycaster.ray.origin.copy(controls.getObject().position);
				raycaster.ray.origin.y -= 10;
				const intersections = raycaster.intersectObjects(objects);
				const onObject = intersections.length > 0;
				const delta = (performanceNow - prevTime) / 1000;
				velocity.x -= velocity.x * 10.0 * delta;
				velocity.z -= velocity.z * 10.0 * delta;
				velocity.y -= 9.8 * 2.0 * delta; // 100.0 = mass
				direction.z = Number(moveForward) - Number(moveBackward);
				direction.x = Number(moveRight) - Number(moveLeft);
				direction.normalize(); // this ensures consistent movements in all directions
				if (moveForward || moveBackward) velocity.z -= direction.z * speederBoi * delta;
				if (moveLeft || moveRight) velocity.x -= direction.x * speederBoi * delta;
				if (onObject === true) {
					velocity.y = Math.max(0, velocity.y);
					canJump = true;
				}
				controls.moveRight(-velocity.x * delta);
				controls.moveForward(-velocity.z * delta);
				controls.getObject().position.y += (velocity.y * delta); // new behavior

				if (controls.getObject().position.y < 0) {
					velocity.y = 0;
					controls.getObject().position.y = 0;
					canJump = false;
				}
			}

			for (let i = 0; i < scene.children.length; i++) {

				const object = scene.children[i];
				if (object instanceof THREE.Points) {
					object.rotation.y = performanceNow * (i < 1 ? i - 0.000015 : -(i + 1));
				}
			}

			prevTime = performanceNow;

			light.position.set(0, 0, 0);

			time = clock.getElapsedTime() * 0.03 * Math.PI;
			ring1.forEach((c, ndx) => {
				c.position.set(
					Math.cos(time + Math.PI * 0.1 * ndx) * radius,
					Math.sin(time + Math.PI * 0.1 * ndx) * radius,
					0
				)
			})

			renderer.render(scene, camera);
		}

		init();
		animate();
	</script>
</body>

</html>
